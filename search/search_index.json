{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.\\_]+"},"docs":[{"location":"","text":"BigOS BigOS is an operating system developed by students at the University of Wroc\u0142aw. Dependencies (minimum version) CMake (3.24) + makefile generator qemu-system-riscv riscv64-elf-gcc clang-format (19.0) MkDocs (1.4.2) \u2013 only for documentation Building Quickstart Complete information about build system can be found in build system docs . Here is just enough to get you started. Cross-Compiling Clone and enter the repository, then run: cmake --preset=<your-preset> cmake --build To list all available presets run: cmake --list-presets # Some notable presets: # debug # release # release-size (optimize for size) # release-debug (release with debug info) Running To run the OS in QEMU use one of the targets: cmake --build build --target run-<target to run> # ex. run-example_sbi # To exit just enter Ctrl+a x All available targets are listed in build system target docs . Contributing Before contributing please familiarize yourself with the rules . Documentation Documentation is available at github pages . Offline Documentation Can be generated using MkDocs: mkdocs build # Or to serve it locally: # mkdocs serve","title":"Home"},{"location":"#bigos","text":"BigOS is an operating system developed by students at the University of Wroc\u0142aw.","title":"BigOS"},{"location":"#dependencies-minimum-version","text":"CMake (3.24) + makefile generator qemu-system-riscv riscv64-elf-gcc clang-format (19.0) MkDocs (1.4.2) \u2013 only for documentation","title":"Dependencies (minimum version)"},{"location":"#building-quickstart","text":"Complete information about build system can be found in build system docs . Here is just enough to get you started.","title":"Building Quickstart"},{"location":"#cross-compiling","text":"Clone and enter the repository, then run: cmake --preset=<your-preset> cmake --build To list all available presets run: cmake --list-presets # Some notable presets: # debug # release # release-size (optimize for size) # release-debug (release with debug info)","title":"Cross-Compiling"},{"location":"#running","text":"To run the OS in QEMU use one of the targets: cmake --build build --target run-<target to run> # ex. run-example_sbi # To exit just enter Ctrl+a x All available targets are listed in build system target docs .","title":"Running"},{"location":"#contributing","text":"Before contributing please familiarize yourself with the rules .","title":"Contributing"},{"location":"#documentation","text":"Documentation is available at github pages .","title":"Documentation"},{"location":"#offline-documentation","text":"Can be generated using MkDocs: mkdocs build # Or to serve it locally: # mkdocs serve","title":"Offline Documentation"},{"location":"about/","text":"About Page // TODO: Fill in this page.","title":"About"},{"location":"about/#about-page","text":"// TODO: Fill in this page.","title":"About Page"},{"location":"acronyms/","text":"A Arg - Argument ASCII - American Standard Code for Information Interchange B BIOS - Basic input/output system C CLI - Command Line Interface CPU - Central processing unit E ELF - Executable and Linkable Format EOF - End of File Exec - Execute EXT - Extended File System (ext2, ext3, ext4) F f32 - single-precision, 32-bit IEEE 754 floating-point representation f64 - double-precision, 64-bit IEEE 754 floating-point representation FAT - File Allocation Table FS - File System G GUI - Graphical User Interface I i16 - 16-bit signed integer i32 - 32-bit signed integer i64 - 64-bit signed integer i8 - 8-bit signed integer Inx - Index M Max - Maximum Min - Minimum Msg - Message N Num - Number O Opt - Option OS - Operating system P PID - Process Identifier Pos - Position Ptr - Pointer U u16 - 16-bit unsigned integer u32 - 32-bit unsigned integer u64 - 64-bit unsigned integer u8 - 8-bit unsigned integer UEFI - Unified Extensible Firmware Interface uefi - Unified Extensible Firmware Interface V Val - Value VFS - Virtual File System","title":"Acronyms"},{"location":"acronyms/#a","text":"Arg - Argument ASCII - American Standard Code for Information Interchange","title":"A"},{"location":"acronyms/#b","text":"BIOS - Basic input/output system","title":"B"},{"location":"acronyms/#c","text":"CLI - Command Line Interface CPU - Central processing unit","title":"C"},{"location":"acronyms/#e","text":"ELF - Executable and Linkable Format EOF - End of File Exec - Execute EXT - Extended File System (ext2, ext3, ext4)","title":"E"},{"location":"acronyms/#f","text":"f32 - single-precision, 32-bit IEEE 754 floating-point representation f64 - double-precision, 64-bit IEEE 754 floating-point representation FAT - File Allocation Table FS - File System","title":"F"},{"location":"acronyms/#g","text":"GUI - Graphical User Interface","title":"G"},{"location":"acronyms/#i","text":"i16 - 16-bit signed integer i32 - 32-bit signed integer i64 - 64-bit signed integer i8 - 8-bit signed integer Inx - Index","title":"I"},{"location":"acronyms/#m","text":"Max - Maximum Min - Minimum Msg - Message","title":"M"},{"location":"acronyms/#n","text":"Num - Number","title":"N"},{"location":"acronyms/#o","text":"Opt - Option OS - Operating system","title":"O"},{"location":"acronyms/#p","text":"PID - Process Identifier Pos - Position Ptr - Pointer","title":"P"},{"location":"acronyms/#u","text":"u16 - 16-bit unsigned integer u32 - 32-bit unsigned integer u64 - 64-bit unsigned integer u8 - 8-bit unsigned integer UEFI - Unified Extensible Firmware Interface uefi - Unified Extensible Firmware Interface","title":"U"},{"location":"acronyms/#v","text":"Val - Value VFS - Virtual File System","title":"V"},{"location":"contributing_rules/","text":"Contributing rules Languages To keep things simple the only allowed language is C23 and assembly where needed. License All source files should start with the following license header: <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Formatting Ensure your code is properly formatted before submitting a pull request (use scripts/format.sh ). Naming conventions Use snake_case for names (including file names). Use _t at the end of typedef definitions. Use ALL_CAPS for MACROS. Use ALL_CAPS for enum values and include the name of the enum at the beginning of the value name. Prefix global variables with g_ . Naming rules Don't use magic numbers, use #define or const variables to name them (within reason). Don't use acronyms others then the ones specified here . Comments If using comment labels please write them like this: //TODO: //NOTE: //WARNING: //BUG: //PERF: \u2013 for marking code that needs optimization //FIX: \u2013 for marking code that needs fixing //HACK: \u2013 for marking a temporary solution that needs redoing //TEST: \u2013 for marking code used for testing Use Doxygen-style comments for functions and structs. Update comments when modifying code! The colon after labeled comments is important for TODO -searching scripts Git No Warnings, TODOs, Bugs, Fixes, Hacks and Tests on the main branch. Keep the Git history clean. Write meaningful commit messages. All code must be reviewed before merging. Use pull requests, no direct pushes to main. Code must pass all checks before merging. Code must be tested before merging. At least 2 approvals required before merging.","title":"Contributing rules"},{"location":"contributing_rules/#contributing-rules","text":"","title":"Contributing rules"},{"location":"contributing_rules/#languages","text":"To keep things simple the only allowed language is C23 and assembly where needed.","title":"Languages"},{"location":"contributing_rules/#license","text":"All source files should start with the following license header: <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.","title":"License"},{"location":"contributing_rules/#formatting","text":"Ensure your code is properly formatted before submitting a pull request (use scripts/format.sh ).","title":"Formatting"},{"location":"contributing_rules/#naming-conventions","text":"Use snake_case for names (including file names). Use _t at the end of typedef definitions. Use ALL_CAPS for MACROS. Use ALL_CAPS for enum values and include the name of the enum at the beginning of the value name. Prefix global variables with g_ .","title":"Naming conventions"},{"location":"contributing_rules/#naming-rules","text":"Don't use magic numbers, use #define or const variables to name them (within reason). Don't use acronyms others then the ones specified here .","title":"Naming rules"},{"location":"contributing_rules/#comments","text":"If using comment labels please write them like this: //TODO: //NOTE: //WARNING: //BUG: //PERF: \u2013 for marking code that needs optimization //FIX: \u2013 for marking code that needs fixing //HACK: \u2013 for marking a temporary solution that needs redoing //TEST: \u2013 for marking code used for testing Use Doxygen-style comments for functions and structs. Update comments when modifying code! The colon after labeled comments is important for TODO -searching scripts","title":"Comments"},{"location":"contributing_rules/#git","text":"No Warnings, TODOs, Bugs, Fixes, Hacks and Tests on the main branch. Keep the Git history clean. Write meaningful commit messages. All code must be reviewed before merging. Use pull requests, no direct pushes to main. Code must pass all checks before merging. Code must be tested before merging. At least 2 approvals required before merging.","title":"Git"},{"location":"build_system/","text":"Build System It's cmake. // TODO: Document the file system","title":"Build System"},{"location":"build_system/#build-system","text":"It's cmake. // TODO: Document the file system","title":"Build System"},{"location":"build_system/targets/","text":"Run Targets run-example_sbi run-example_machine // TODO: Fill in information about run targets","title":"Run Targets"},{"location":"build_system/targets/#run-targets","text":"run-example_sbi run-example_machine // TODO: Fill in information about run targets","title":"Run Targets"},{"location":"vfs/Create_Delete/","text":"Create, Delete WIP","title":"Create, Delete"},{"location":"vfs/Create_Delete/#create-delete","text":"WIP","title":"Create, Delete"},{"location":"vfs/Open/","text":"Open, Close WIP","title":"Open, Close"},{"location":"vfs/Open/#open-close","text":"WIP","title":"Open, Close"},{"location":"vfs/Protocol/","text":"VFS FS Server Protocol TODO: invent a name for this protocol For reference see vfs/fs_server_protocol.h This is the protocol used for communication with FS Servers. It allows for performing all necesary operations to manage, access and modify a file system. FS Server This term describes a userspace application that: Creates a server handle via call to open in {TBD, maybe /serv?/}/ . The result of this call will be a readable fd . Accepts and responds to messages on fd using FS server protocol Protocol The FS Server Protocol consists of requests and responses to requests; all requests must receive exactly one response. Conventions Binary representations for data sent over streams use the following conventions: All multi-byte integers are sent in little -endian format Fields are packed tightly, no implicit padding is used Fields are listed in the order they are sent data[<size>] corresponds to a <size> byte field named data If <size> is not a constant then the length is specified by a preceding field (...)[<count>] corresponds to an array of <count> elements If <count> is not a constant then the length is specified by a preceding field Strings are sent in UTF-8 encoding without a trailing null byte Metadata All requests/responses preceded by a metadata section containing: size[4] tag[2] type[2] Where: size \u2013 total size of the request (including this field) tag \u2013 unique identifier for the request type \u2013 type of request/response; Fs servers receive requests type, vfs receives response type This can be thought of as a transport layer header for the protocol. Request-Response Types VERSION Used to initiate connection, exactly one request-response messages should be exchanged before any other request is made. Client and server negotiate the maximal response size and protocol version (not used now, but maybe...). If error response is received the server will not be registered. Request max_size[4] version[4] Where: max_size \u2013 max total response size version \u2013 client protocol version implementation Response max_size[4] version[4] Where: - u32 max_size \u2013 max total request size - u32 FSProtocolVersion_t version \u2013 server protocol version implementation CONNECT Used to receiveq a cursor to a root of fs tree. The cursor is an abstract pointer to a file used for navigating the fs tree. Request uid[4] Where: uid \u2013 user ID for checking permissions Response cursor[8] Where: cursor \u2013 a unique identifier for a file in the file system WALK Given a cursor and a list of names of subsequent directories to enter, this request returns a new cursor to the last directory in the list. Request cursor[8] uid[4] walk_count[2] (name_size[2] name[name_size])[walk_count] Where: cursor \u2013 a cursor from which to start walking the file system uid \u2013 user ID for checking permissions walk_count \u2013 number of subsequent directories to enter name_size \u2013 size of the name in bytes name \u2013 name of the directory to enter Response cursor[8] Where: cursor \u2013 a new cursor to the last directory in the list. If the walk was unsuccessful an error response is returned instead. STAT Given a cursor returns metadata of pointed file. Request cursor[8] uid[4] Where: cursor \u2013 a cursor to the file to get metadata for uid \u2013 user ID for checking permissions Response size[2] stat[size] Where: size \u2013 size of the stat structure in bytes stat \u2013 a struct stat containing metadata of the file CREATE Creates a new file or directory at the location pointed to by the cursor . Request cursor[8] uid[4] options[4] name_size[2] name[name_size] Where: cursor \u2013 a cursor to the directory to create the file in uid \u2013 user ID for checking permissions options \u2013 options for creating the file, see CREATE_OPTIONS name_size \u2013 size of the name in bytes name \u2013 name of the file to create Response cursor[8] Where: cursor \u2013 a new cursor to the created file. If the creation was unsuccessful an error response is returned instead. DELETE Deletes a file or directory at the location pointed to by the cursor . After deletion the cursor is no longer valid. Request cursor[8] uid[4] Where: cursor \u2013 a cursor to the file to delete uid \u2013 user ID for checking permissions Response Empty response (consisting only of metadata) is given on success, error response is returned otherwise. OPEN Given a cursor opens a file and returns a handle for reading/writing (depending on flags). Returned handle is guaranteed to be unique and valid untile the file is closed (unless server explodes). Request cursor[8] uid[4] flags[4] Where: cursor \u2013 a cursor to the file to open uid \u2013 user ID for checking permissions flags \u2013 flags for opening the file, see OPEN_FLAGS Response handle[8] max_atomic_op[4] Where: handle \u2013 a unique identifier for the opened file, used for subsequent read/write operations. If the open was unsuccessful an error response is returned instead. max_atomic_op \u2013 maximum size of an atomic operation that can be performed on the file, in bytes. READ Given a readable handle reads data from the file. Request handle[8] offset[8] size[4] Where: handle \u2013 a handle to the file to read from offset \u2013 offset in the file to read from, in bytes size \u2013 size of the data to read, in bytes Response size[4] data[size] Where: size \u2013 size of the data read, in bytes data \u2013 data read from the file WRITE Given a writable handle writes data to the file. Request handle[8] offset[8] size[4] data[size] Where: handle \u2013 a handle to the file to write to offset \u2013 offset in the file to write to, in bytes size \u2013 size of the data to write, in bytes data \u2013 data to write to the file Response size[4] Where: size \u2013 size of the data written, in bytes WSTAT Given a writable handle updates metadata of the file. Request handle[8] size[2] stat[size] Where: handle \u2013 a handle to the file to update metadata for size \u2013 size of the stat structure in bytes stat \u2013 a struct stat containing metadata to update Response Empty response is given on success. CLOSE Closes a file handle, after this call the handle is no longer valid. Request handle[8] Where: handle \u2013 a handle to the file to close Response Empty response is given on success. ERROR This is a special response sent by the server in case of an error. It can be sent in response to any request, but is not a request itself. Response ```text size[2] error_name[size] ```` Where: size \u2013 size of the error_name string in bytes error_name \u2013 name of the error, a string in UTF-8 encoding without a trailing null byte","title":"VFS FS Server Protocol"},{"location":"vfs/Protocol/#vfs-fs-server-protocol","text":"TODO: invent a name for this protocol For reference see vfs/fs_server_protocol.h This is the protocol used for communication with FS Servers. It allows for performing all necesary operations to manage, access and modify a file system.","title":"VFS FS Server Protocol"},{"location":"vfs/Protocol/#fs-server","text":"This term describes a userspace application that: Creates a server handle via call to open in {TBD, maybe /serv?/}/ . The result of this call will be a readable fd . Accepts and responds to messages on fd using FS server protocol","title":"FS Server"},{"location":"vfs/Protocol/#protocol","text":"The FS Server Protocol consists of requests and responses to requests; all requests must receive exactly one response.","title":"Protocol"},{"location":"vfs/Protocol/#conventions","text":"Binary representations for data sent over streams use the following conventions: All multi-byte integers are sent in little -endian format Fields are packed tightly, no implicit padding is used Fields are listed in the order they are sent data[<size>] corresponds to a <size> byte field named data If <size> is not a constant then the length is specified by a preceding field (...)[<count>] corresponds to an array of <count> elements If <count> is not a constant then the length is specified by a preceding field Strings are sent in UTF-8 encoding without a trailing null byte","title":"Conventions"},{"location":"vfs/Protocol/#metadata","text":"All requests/responses preceded by a metadata section containing: size[4] tag[2] type[2] Where: size \u2013 total size of the request (including this field) tag \u2013 unique identifier for the request type \u2013 type of request/response; Fs servers receive requests type, vfs receives response type This can be thought of as a transport layer header for the protocol.","title":"Metadata"},{"location":"vfs/Protocol/#request-response-types","text":"","title":"Request-Response Types"},{"location":"vfs/Protocol/#version","text":"Used to initiate connection, exactly one request-response messages should be exchanged before any other request is made. Client and server negotiate the maximal response size and protocol version (not used now, but maybe...). If error response is received the server will not be registered.","title":"VERSION"},{"location":"vfs/Protocol/#request","text":"max_size[4] version[4] Where: max_size \u2013 max total response size version \u2013 client protocol version implementation","title":"Request"},{"location":"vfs/Protocol/#response","text":"max_size[4] version[4] Where: - u32 max_size \u2013 max total request size - u32 FSProtocolVersion_t version \u2013 server protocol version implementation","title":"Response"},{"location":"vfs/Protocol/#connect","text":"Used to receiveq a cursor to a root of fs tree. The cursor is an abstract pointer to a file used for navigating the fs tree.","title":"CONNECT"},{"location":"vfs/Protocol/#request_1","text":"uid[4] Where: uid \u2013 user ID for checking permissions","title":"Request"},{"location":"vfs/Protocol/#response_1","text":"cursor[8] Where: cursor \u2013 a unique identifier for a file in the file system","title":"Response"},{"location":"vfs/Protocol/#walk","text":"Given a cursor and a list of names of subsequent directories to enter, this request returns a new cursor to the last directory in the list.","title":"WALK"},{"location":"vfs/Protocol/#request_2","text":"cursor[8] uid[4] walk_count[2] (name_size[2] name[name_size])[walk_count] Where: cursor \u2013 a cursor from which to start walking the file system uid \u2013 user ID for checking permissions walk_count \u2013 number of subsequent directories to enter name_size \u2013 size of the name in bytes name \u2013 name of the directory to enter","title":"Request"},{"location":"vfs/Protocol/#response_2","text":"cursor[8] Where: cursor \u2013 a new cursor to the last directory in the list. If the walk was unsuccessful an error response is returned instead.","title":"Response"},{"location":"vfs/Protocol/#stat","text":"Given a cursor returns metadata of pointed file.","title":"STAT"},{"location":"vfs/Protocol/#request_3","text":"cursor[8] uid[4] Where: cursor \u2013 a cursor to the file to get metadata for uid \u2013 user ID for checking permissions","title":"Request"},{"location":"vfs/Protocol/#response_3","text":"size[2] stat[size] Where: size \u2013 size of the stat structure in bytes stat \u2013 a struct stat containing metadata of the file","title":"Response"},{"location":"vfs/Protocol/#create","text":"Creates a new file or directory at the location pointed to by the cursor .","title":"CREATE"},{"location":"vfs/Protocol/#request_4","text":"cursor[8] uid[4] options[4] name_size[2] name[name_size] Where: cursor \u2013 a cursor to the directory to create the file in uid \u2013 user ID for checking permissions options \u2013 options for creating the file, see CREATE_OPTIONS name_size \u2013 size of the name in bytes name \u2013 name of the file to create","title":"Request"},{"location":"vfs/Protocol/#response_4","text":"cursor[8] Where: cursor \u2013 a new cursor to the created file. If the creation was unsuccessful an error response is returned instead.","title":"Response"},{"location":"vfs/Protocol/#delete","text":"Deletes a file or directory at the location pointed to by the cursor . After deletion the cursor is no longer valid.","title":"DELETE"},{"location":"vfs/Protocol/#request_5","text":"cursor[8] uid[4] Where: cursor \u2013 a cursor to the file to delete uid \u2013 user ID for checking permissions","title":"Request"},{"location":"vfs/Protocol/#response_5","text":"Empty response (consisting only of metadata) is given on success, error response is returned otherwise.","title":"Response"},{"location":"vfs/Protocol/#open","text":"Given a cursor opens a file and returns a handle for reading/writing (depending on flags). Returned handle is guaranteed to be unique and valid untile the file is closed (unless server explodes).","title":"OPEN"},{"location":"vfs/Protocol/#request_6","text":"cursor[8] uid[4] flags[4] Where: cursor \u2013 a cursor to the file to open uid \u2013 user ID for checking permissions flags \u2013 flags for opening the file, see OPEN_FLAGS","title":"Request"},{"location":"vfs/Protocol/#response_6","text":"handle[8] max_atomic_op[4] Where: handle \u2013 a unique identifier for the opened file, used for subsequent read/write operations. If the open was unsuccessful an error response is returned instead. max_atomic_op \u2013 maximum size of an atomic operation that can be performed on the file, in bytes.","title":"Response"},{"location":"vfs/Protocol/#read","text":"Given a readable handle reads data from the file.","title":"READ"},{"location":"vfs/Protocol/#request_7","text":"handle[8] offset[8] size[4] Where: handle \u2013 a handle to the file to read from offset \u2013 offset in the file to read from, in bytes size \u2013 size of the data to read, in bytes","title":"Request"},{"location":"vfs/Protocol/#response_7","text":"size[4] data[size] Where: size \u2013 size of the data read, in bytes data \u2013 data read from the file","title":"Response"},{"location":"vfs/Protocol/#write","text":"Given a writable handle writes data to the file.","title":"WRITE"},{"location":"vfs/Protocol/#request_8","text":"handle[8] offset[8] size[4] data[size] Where: handle \u2013 a handle to the file to write to offset \u2013 offset in the file to write to, in bytes size \u2013 size of the data to write, in bytes data \u2013 data to write to the file","title":"Request"},{"location":"vfs/Protocol/#response_8","text":"size[4] Where: size \u2013 size of the data written, in bytes","title":"Response"},{"location":"vfs/Protocol/#wstat","text":"Given a writable handle updates metadata of the file.","title":"WSTAT"},{"location":"vfs/Protocol/#request_9","text":"handle[8] size[2] stat[size] Where: handle \u2013 a handle to the file to update metadata for size \u2013 size of the stat structure in bytes stat \u2013 a struct stat containing metadata to update","title":"Request"},{"location":"vfs/Protocol/#response_9","text":"Empty response is given on success.","title":"Response"},{"location":"vfs/Protocol/#close","text":"Closes a file handle, after this call the handle is no longer valid.","title":"CLOSE"},{"location":"vfs/Protocol/#request_10","text":"handle[8] Where: handle \u2013 a handle to the file to close","title":"Request"},{"location":"vfs/Protocol/#response_10","text":"Empty response is given on success.","title":"Response"},{"location":"vfs/Protocol/#error","text":"This is a special response sent by the server in case of an error. It can be sent in response to any request, but is not a request itself.","title":"ERROR"},{"location":"vfs/Protocol/#response_11","text":"```text size[2] error_name[size] ```` Where: size \u2013 size of the error_name string in bytes error_name \u2013 name of the error, a string in UTF-8 encoding without a trailing null byte","title":"Response"},{"location":"vfs/Read/","text":"READ WIP","title":"READ"},{"location":"vfs/Read/#read","text":"WIP","title":"READ"},{"location":"vfs/Stat/","text":"Stat, Wstat WIP","title":"Stat, Wstat"},{"location":"vfs/Stat/#stat-wstat","text":"WIP","title":"Stat, Wstat"},{"location":"vfs/Walk/","text":"Walk, Connect WIP","title":"Walk, Connect"},{"location":"vfs/Walk/#walk-connect","text":"WIP","title":"Walk, Connect"},{"location":"vfs/Write/","text":"Write WIP","title":"Write"},{"location":"vfs/Write/#write","text":"WIP","title":"Write"}]}